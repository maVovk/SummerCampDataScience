"""
Если подходить с нуля, то в простейшем случае векторы реализуются в виде списков чисел.
Список из трех чисел соответствует вектору в трехмерном пространстве, и наоборот:
"""
import math
from typing import List

Vector = List[float]
height_weight_age = [184,
                     76,
                     22]  # Сантиметры Годы  килограммы

grades = [45,  # kpl
          85,  # kp2
          95,  # kpЗ
          62]  # kp4
"""
Нередко приходится складывать два вектора. Векторы складывают покомпонентно, 
т.е. если два вектора v и w имеют одинаковую длину, то их сумма - это вектор, 
чей первый элемент равен v[0] + w[0], второй - v[1] + w[1] и т. д. (Если длины 
векторов разные, то операция сложения не разрешена.)
Например, сложение векторов [1, 2] и [2, 1] даст [1 + 2, 2 + 1] или [3, 3] 

Это легко можно имплементировать объединением двух векторов посредством 
функции zip и сложением соответствующих элементов с помощью операции включения в список: 
"""


def add(v: Vector, w: Vector) -> Vector:  # add([1, 2, 3], [4, 5, 6]) == [5, 7, 9]
    # Складывает соответствующие элементы
    assert len(v) == len(w), "векторы должны иметь одинаковую длину"
    return [v_i + w_i for v_i, w_i in zip(v, w)]


"""
Для получения разности двух векторов мы вычитаем соответствующие элементы:
"""


def subtract(v: Vector, w: Vector) -> Vector:  # subtract([5, 7, 9], [4, 5, 6]) == [1, 2, 3]
    # Вычитает соответствующие элементы
    assert len(v) == len(w), "векторы должны иметь одинаковую длину"
    return [v_i - w_i for v_i, w_i in zip(v, w)]


"""
Нам также иногда может понадобиться покомпонентная сумма списка векторов, 
т.е. нужно создать новый вектор, чей первый элемент равен сумме всех первых 
элементов, а второй элемент - сумме всех вторых элементов и т.д:
"""


def vector_sum(vectors: List[Vector]) -> Vector:  # vector_sum([[1, 2], [3, 4], [5, 6], [7, 8]]) == [16, 20]
    # Суммирует все соответствующие элементы
    # Проверить, что векторы не пустые
    assert vectors, "векторы не предоставлены!"
    # Проверить, что векторы имеют о.ш,�наковый размер
    num_elements = len(vectors[0])
    assert all(len(v) == num_elements for v in vectors), "разные размеры!"
    # i-й элемент результата является суммой каждого элемента vector[i]
    return [sum(vector[i] for vector in vectors)
            for i in range(num_elements)]


"""
Нам еще понадобится умножение вектора на скаляр, которое реализуется простым 
умножением каждого элемента вектора на это число:
"""


def scalar_multiply(c: float, v: Vector) -> Vector:  # scalar_multiply(2, [1, 2, 3]) == [2, 4, 6]
    # Умножает каждый элемент на с
    return [c * v_i for v_i in v]


"""
Эта функция позволяет нам вычислять покомпонентные средние значения списка 
векторов (одинакового размера):
"""


def vector_mean(vectors: List[Vector]) -> Vector:  # vector_mean([[1, 2], [3, 4], [5, 6]]) == [3, 4]
    # Вычисляет поэлементное среднее арифметическое
    n = len(vectors)
    return scalar_multiply(1 / n, vector_sum(vectors))


"""
Менее очевидный инструмент - это точечное, или скалярное произведение (т.е. 
производящее скалярный результат). Скалярное произведение двух векторов есть 
сумма их покомпонентных произведений:
"""


def dot(v: Vector, w: Vector) -> float:  # dot([1, 2, 3], [4, 5, 6]) == 32   1 * 4 + 2 * 5 + 3 * 6
    # Вычисляет v 1 * w 1 + ... + v n * w n
    assert len(v) == len(w), "векторы должны иметь одинаковую длину"
    return sum(v_i * w_i for v_i, w_i in zip(v, w))


"""
Если w имеет магнитуду, равную 1, то скалярное произведение служит мерой того, 
насколько далеко вектор v простирается в направлении w. Например, если w = [1,0] 
тогда скалярное произведение dot(v, w) - это просто первый компонент вектора v. 
Выражаясь иначе, это длина вектора, которая получится, если спроецировать вектор v на вектор w.
Используя эту операцию, легко вычислить сумwу квадратов вектора:
"""


def sum_of_squares(v: Vector) -> float:  # sum_of_squares([1, 2, 3]) == 14  # 1 * 1 + 2 * 2 + 3 * 3
    # Возвращает v 1 * v 1 + ... + v n * v n
    # которую можно применить для вычисления его магнитуды(или длины):
    return dot(v, v)


def magnitude(v: Vector) -> float:
    # Возвращает магнитуду (или длину) вектора v
    return math.sqrt(sum_of_squares(v))  # В исходном коде оно выглядит так(три следующих функции):


def squared_distance(v: Vector, w: Vector) -> float:
    # Вычисляет (v_l - w_l) ** 2 + ... + (v_n - w_n) ** 2
    return sum_of_squares(subtract(v, w))


# Вероятно, будет понятнее, если мы запишем эту функцию как (эквивалент):
def distance(v: Vector, w: Vector) -> float:
    return magnitude(subtract(v, w))
